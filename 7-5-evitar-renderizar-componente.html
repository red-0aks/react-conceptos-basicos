<body>
   <div id="root"></div>
   <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
   <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
   <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
   <style>
      body{
         font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }
   </style>
   <script type="text/babel">
      const rootElement = ReactDOM.createRoot(document.getElementById('root'))
      // En casos excepcionales, es posible que desees que un componente se oculte 
      // a sí mismo aunque haya sido renderizado por otro componente. 
      // Para hacer esto, devuelve null en lugar del resultado de renderizado.

      // En el siguiente ejemplo, el <WarningBanner /> se renderiza dependiendo 
      // del valor del prop llamado warn. Si el valor del prop es false, 
      // entonces el componente no se renderiza:
      function WarningBanner(props) {
         if (!props.warn) {
            return null;
         }
         return (
            <div className="warning">
               Warning!
            </div>
         );
      }

      class Page extends React.Component {
         constructor(props) {
            super(props)
            this.state = {showWarning: true}
            this.handleToggleClick = this.handleToggleClick.bind(this) 
         }

         handleToggleClick() {
            this.setState(state => ({
               showWarning: !state.showWarning
            }))
         }

         render() {
            return (
               <div>
                  <WarningBanner warn={this.state.showWarning}/>
                  <button onClick={this.handleToggleClick}>
                     {this.state.showWarning ? 'Hide' : 'Show'}
                  </button>
               </div>
            );
         }
      }

      // El devolver null desde el método render de un componente no influye 
      // en la activación de los métodos del ciclo de vida del componente. 
      // Por ejemplo componentDidUpdate seguirá siendo llamado.
      const element = (
         <Page />
      );
      
      rootElement.render(element)
   </script>
</body>